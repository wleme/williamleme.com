[{"content":"Hello! I\u0026rsquo;m a head of software development based in sunny Jacksonville, Florida / USA. I’m all about adding value to software products, helping businesses achieve their goals, automating processes, making customers happy, promoting a growth mindset within businesses and people, and creating strong teams. You can check out my professional profile on my LinkedIn page.\nMy focus is on the business of software, scalable software architecture, software quality, Agile/Lean business operations, Cloud platforms, Javascript/Typescript, c#, .Net Core, NodeJs, Angular, VueJs, Ionic, Sql/NoSql Databases and DevOps.\nYou can reach me at contact@williamleme.com\n","href":"/","title":""},{"content":"Any business is either selling their services / goods to other businesses (B2B) or to consumers (B2C). There\u0026rsquo;s also a type of business that sells to other businesses which end-up selling to consumers (B2B2C) B2B stands for Business to business but can also be called boring to boring and that\u0026rsquo;s due to the fact of some sort of conservatism\nB2C is brutal as it takes no time for you (the consumer) to go from a paid solution A to a paid solution B. Think about Evernote. Let\u0026rsquo;s say you want to replace Evernote with something else. Yes you will need to go thruophug some sort of export/import of your information but that\u0026rsquo;s it. The process of making this decision of replacing Evernote is\u0026hellip;. What\u0026rsquo;s the only thing left for Evernote ? Show you they are worth their price by constantly keep adding features and twiking their product, or if you will, by constantly innovating. B2C is brutal because Evernote and their major competitors are doing the same, Innovating for the sake of you not jumping to a differente service. and this race.\nOn the other side B2B has a more formal business relationship where replacing services is not as trivial as replacing a note taking app. Businesses and vendors build a relatinship along the years and replacing a service is a strategic/financial decision that takes time and usually goes thru a tree of decision makers.\nthe email platform service that you use\u0026hellip;.. Those services try to lock you in but the reality is\n","href":"/posts/2020/004-b2b-innovations/","title":"Driving B2B innovations with a B2C mindset."},{"content":"","href":"/posts/","title":"Posts"},{"content":"","href":"/tags/blazor/","title":"blazor"},{"content":" In this tutorial we will be creating a blazor component that receives the chart data and passes it to the Chart js library. This component will be limited to a Pie and Bar types but the idea is the same in case you want to implement other types.\nAdding Chart.js to the project Go to index html and add the Chart.js library from their cdn\n1 2  \u0026lt;!--index.html--\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.bundle.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   Creating a Chart blazor component We are going to create a new file called Chart.razor. Our component will receive all the data from the parent and pass it down to the Chart.js library via Javascript interop. It will have the following properties: Id, Type, Data, BackgroundColor and Labels. Usage example: \u0026lt;Chart Id=\u0026quot;pie1\u0026quot; Type=\u0026quot;@Chart.ChartType.Pie\u0026quot; Data=\u0026quot;@(new[] { \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot; })\u0026quot; BackgroundColor=\u0026quot;@(new[] { \u0026quot;blue\u0026quot;,\u0026quot;green\u0026quot;})\u0026quot; Labels=\u0026quot;@(new[] { \u0026quot;Fail\u0026quot;,\u0026quot;Ok\u0026quot;})\u0026quot;\u0026gt;\u0026lt;/Chart\u0026gt;.\nSince we have to have the canvas html element rendered in the page before invoking the library we use OnAfterRenderAsync to do our logic and call the js library. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  @*//Chart.razor*@ @inject IJSRuntime JSRuntime \u0026lt;canvas id=\u0026#34;@Id\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; @code { public enum ChartType { Pie, Bar } [Parameter] public string Id { get; set; } [Parameter] public ChartType Type { get; set; } [Parameter] public string[] Data { get; set; } [Parameter] public string[] BackgroundColor { get; set; } [Parameter] public string[] Labels { get; set; } protected override async Task OnAfterRenderAsync(bool firstRender) { //Here we create an anonymous type with all the options that need to be sent to Chart.js  var config = new { Type = Type.ToString().ToLower(), Options = new { Responsive = true, Scales = new { YAxes = new[] { new { Ticks = new { BeginAtZero=true } } } } }, Data = new { Datasets = new[] { new { Data = Data, BackgroundColor = BackgroundColor} }, Labels = Labels } }; await JSRuntime.InvokeVoidAsync(\u0026#34;setup\u0026#34;, Id, config); } }   \nCalling setup() We create a new javascript file called chart.js which initializes our Chart js component in a function called setup(). It receives the canvas Id and the config options from the blazor component.\n1 2 3 4 5  //chart.js window.setup = (id,config) =\u0026gt; { var ctx = document.getElementById(id).getContext(\u0026#39;2d\u0026#39;); new Chart(ctx, config); }    and then we add chart.js to index.html\n1 2 3  \u0026lt;!--index.html--\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.bundle.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;chart.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   Using the new component Now we have our \u0026lt;Chart\u0026gt; component ready to be used. Simply add the tag to a new page/component E.g. 1 2  \u0026lt;Chart Id=\u0026#34;pie1\u0026#34; Type=\u0026#34;@Chart.ChartType.Pie\u0026#34; Data=\u0026#34;@(new[] { \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34; })\u0026#34; BackgroundColor=\u0026#34;@(new[] { \u0026#34;blue\u0026#34;,\u0026#34;green\u0026#34;})\u0026#34; Labels=\u0026#34;@(new[] { \u0026#34;Fail\u0026#34;,\u0026#34;Ok\u0026#34;})\u0026#34;\u0026gt;\u0026lt;/Chart\u0026gt; \u0026lt;Chart Id=\u0026#34;bar1\u0026#34; Type=\u0026#34;@Chart.ChartType.Bar\u0026#34; Data=\u0026#34;@(new[] { \u0026#34;10\u0026#34;, \u0026#34;9\u0026#34; })\u0026#34; BackgroundColor=\u0026#34;@(new[] { \u0026#34;yellow\u0026#34;,\u0026#34;red\u0026#34;})\u0026#34; Labels=\u0026#34;@(new[] { \u0026#34;Fail\u0026#34;,\u0026#34;Ok\u0026#34;})\u0026#34;\u0026gt;\u0026lt;/Chart\u0026gt;  \nOur component is not setting the dataset label option therefore undefined is rendered.\nConclusion This is a bare bone implementation that can be used as a blueprint if you want to extend it. Chart.js offers many different options to render the charts and they just need to be mapped in our anonymous class. E.g. If we want to create a property that holds the dataset label (and remove undefined from our rendered object) we would have something like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  var config = new { Type = Type.ToString().ToLower(), Options = new { Responsive = true, Scales = new { YAxes = new[] { new { Ticks = new { BeginAtZero=true } } } } }, Data = new { Datasets = new[] { new { Data = Data, BackgroundColor = BackgroundColor, Label=YourNewLabelProperty}  }, Labels = Labels } };   \nHappy Coding!! 😃💻\nWilliam Leme\n","href":"/posts/2020/003-chartjs-blazor/","title":"Chart.js + Blazoar"},{"content":"","href":"/tags/","title":"Tags"},{"content":" I\u0026rsquo;ll be demonstrating how to use Ionic Web Components in a Blazor Web-Assembly App. This demo is built on top of the basic Blazor WASM project template available in Visual Studio.\n1. Import Ionic Web Components\u0026rsquo;s Library into your Blazor App Go to wwwroot\\index.html and add the following to the \u0026lt;head\u0026gt; tag 1 2 3 4  \u0026lt;!--index.html--\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/@ionic/core/dist/ionic/ionic.esm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script nomodule src=\u0026#34;https://cdn.jsdelivr.net/npm/@ionic/core/dist/ionic/ionic.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/@ionic/core/css/ionic.bundle.css\u0026#34;/\u0026gt;`  \nWe also need to change the starting point tag from \u0026lt;app\u0026gt; to \u0026lt;ion-app\u0026gt;\n1 2  \u0026lt;!--index.html--\u0026gt; \u0026lt;ion-app\u0026gt;Loading...\u0026lt;/ion-app\u0026gt;   and tell Blazor our new starting point tag in Program.cs 1 2  //Program.cs builder.RootComponents.Add\u0026lt;App\u0026gt;(\u0026#34;ion-app\u0026#34;);   \n2. Creating a new page Our page is going to let users add new items to a card. We will be using Ionic\u0026rsquo;s ion-input, ion-textarea, ion-card and ion-card-content web components. If the same title is being added more than once we will be displaying a popup message using ion-alert\nA note about data binding and web components Blazor doesn\u0026rsquo;t understand @bind=\u0026quot;Property\u0026quot; on a non-html input element and since we are binding to an ion-input we need to use a combination of value/event: @bind-value=\u0026quot;@Property\u0026quot; @bind-value:event=\u0026quot;oninput\u0026quot;. This combination of value/event is actually what @bind does behind the scenes.\n2.1 Model This is our model that is going to hold the page values 1 2 3 4 5  public class Card { public string Title { get; set; } public string Content { get; set; } }   \n2.2 Page Create a new page under Pages called CardPage.razor and add the following.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  @* CardPage.razor *@ @inject IJSRuntime JSRuntime @page \u0026#34;/card\u0026#34; \u0026lt;div class=\u0026#34;ion-page\u0026#34; id=\u0026#34;main-content\u0026#34;\u0026gt; \u0026lt;ion-header\u0026gt; \u0026lt;ion-toolbar\u0026gt; \u0026lt;ion-buttons slot=\u0026#34;start\u0026#34;\u0026gt; \u0026lt;ion-menu-button\u0026gt;\u0026lt;/ion-menu-button\u0026gt; \u0026lt;/ion-buttons\u0026gt; \u0026lt;ion-title\u0026gt;Cards\u0026lt;/ion-title\u0026gt; \u0026lt;/ion-toolbar\u0026gt; \u0026lt;/ion-header\u0026gt; \u0026lt;ion-content class=\u0026#34;ion-padding\u0026#34;\u0026gt; \u0026lt;ion-item\u0026gt; \u0026lt;ion-label position=\u0026#34;floating\u0026#34;\u0026gt;Title\u0026lt;/ion-label\u0026gt; @* Binding to Title *@ \u0026lt;ion-input @bind-value=\u0026#34;@Title\u0026#34; @bind-value:event=\u0026#34;oninput\u0026#34;\u0026gt;\u0026lt;/ion-input\u0026gt;  \u0026lt;/ion-item\u0026gt; \u0026lt;ion-item\u0026gt; \u0026lt;ion-label position=\u0026#34;floating\u0026#34;\u0026gt;Description\u0026lt;/ion-label\u0026gt; @* Binding to Content *@ \u0026lt;ion-textarea @bind-value=\u0026#34;@Content\u0026#34; @bind-value:event=\u0026#34;oninput\u0026#34;\u0026gt;\u0026lt;/ion-textarea\u0026gt;  \u0026lt;/ion-item\u0026gt; \u0026lt;ion-button color=\u0026#34;primary\u0026#34; @onclick=\u0026#34;AddCard\u0026#34; shape=\u0026#34;round\u0026#34;\u0026gt;Add Card\u0026lt;/ion-button\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ion-item\u0026gt; \u0026lt;ion-label\u0026gt;Total Cards\u0026lt;/ion-label\u0026gt; @* Showing total number of cards *@ \u0026lt;ion-badge slot=\u0026#34;end\u0026#34;\u0026gt;@cards.Count\u0026lt;/ion-badge\u0026gt;  \u0026lt;/ion-item\u0026gt; @foreach (var card in cards) { \u0026lt;ion-card\u0026gt; \u0026lt;ion-card-header\u0026gt; \u0026lt;ion-card-title\u0026gt;@card.Title\u0026lt;/ion-card-title\u0026gt; \u0026lt;/ion-card-header\u0026gt; \u0026lt;ion-card-content\u0026gt; @card.Content \u0026lt;/ion-card-content\u0026gt; \u0026lt;/ion-card\u0026gt; } \u0026lt;/div\u0026gt; \u0026lt;/ion-content\u0026gt; \u0026lt;/div\u0026gt; @code { private List\u0026lt;Card\u0026gt; cards = new List\u0026lt;Card\u0026gt;(); private string Title; private string Content; private async Task AddCard() { if (!string.IsNullOrEmpty(Title)) { if (cards.Any(x =\u0026gt; x.Title == Title)) { @* If Title already exists, show a message *@ await JSRuntime.InvokeVoidAsync(\u0026#34;showIonAlert\u0026#34;);  return; } cards.Add(new Card { Title = Title, Content = Content }); Title = string.Empty; Content = string.Empty; } } }    2.3 Showing a message using ion-message We need to use blazor javascript interop in order to display a popup message using ion-alert. Go to index.html and add the folloing script to the \u0026lt;head\u0026gt; tag under a \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; tag 1 2 3 4 5 6 7 8 9  window.showIonAlert = () =\u0026gt; { const alert = document.createElement(\u0026#39;ion-alert\u0026#39;); alert.header = \u0026#39;Alert\u0026#39;; alert.message = \u0026#39;Title already in the list.\u0026#39;; alert.buttons = [\u0026#39;OK\u0026#39;]; document.body.appendChild(alert); return alert.present(); }   \nand then we can call this js function from Blazor await JSRuntime.InvokeVoidAsync(\u0026quot;showIonAlert\u0026quot;); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @code { private List\u0026lt;Card\u0026gt; cards = new List\u0026lt;Card\u0026gt;(); private string Title; private string Content; private async Task AddCard() { if (!string.IsNullOrEmpty(Title)) { if (cards.Any(x =\u0026gt; x.Title == Title)) { @* If Title already exists, show a message *@ await JSRuntime.InvokeVoidAsync(\u0026#34;showIonAlert\u0026#34;);  return; } cards.Add(new Card { Title = Title, Content = Content }); Title = string.Empty; Content = string.Empty; } }   \n3. Adding navigation We will be using ion-menu and blazor\u0026rsquo;s NavigationManager to provide navigation within our app. We will have just one menu item that is going to take the user to our brand new page.\nGo to Shared\\MainLayout.razor and replace everything with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  @*//MainLayour.razor *@ @inherits LayoutComponentBase @inject NavigationManager NavigationManager @*// Pulling NavigationManager from the DI conteiner *@  \u0026lt;ion-menu side=\u0026#34;start\u0026#34; content-id=\u0026#34;main-content\u0026#34;\u0026gt; \u0026lt;ion-header\u0026gt; \u0026lt;ion-toolbar translucent\u0026gt; \u0026lt;ion-title\u0026gt;Menu\u0026lt;/ion-title\u0026gt; \u0026lt;/ion-toolbar\u0026gt; \u0026lt;/ion-header\u0026gt; \u0026lt;ion-content\u0026gt; \u0026lt;ion-list\u0026gt; @*// Handling onclick *@  \u0026lt;ion-item @onclick=\u0026#34;NavigateToComponent\u0026#34;\u0026gt;  \u0026lt;ion-icon name=\u0026#34;add-circle-outline\u0026#34; slot=\u0026#34;start\u0026#34;\u0026gt;\u0026lt;/ion-icon\u0026gt; \u0026lt;ion-label\u0026gt;Add Card\u0026lt;/ion-label\u0026gt; \u0026lt;/ion-item\u0026gt; \u0026lt;/ion-list\u0026gt; \u0026lt;/ion-content\u0026gt; \u0026lt;/ion-menu\u0026gt; @*// Placeholder where all the pages will be rendered *@ @Body  @code { private void NavigateToComponent() { @*// Going to our new page *@  NavigationManager.NavigateTo(\u0026#34;counter\u0026#34;); } }   \nAnd there we go. We have a simple Blazor app using Ionic Web Components.\n","href":"/posts/2020/002-using-ionic-ui-in-blazor/","title":"Using Ionic Ui Web components in a Blazor App"},{"content":" Url: https://s.wllapps.com\nI have put together a new app: A url shortener web app hosted at https://s.wllapps.com and built with nodejs / express + ejs + redis + mongodb. The idea is really simple, a full url is provided and a short version of it is returned e.g. s.wllapps.com/code where code is the unique identifier for that specific url.\nWhen a new url comes in, this app generates a new code and stores it in nodejs. When there\u0026rsquo;s a request for a given code the web app pulls the mongo db document and redirects the user to its url.\nMongoDb and Redis ? I save the url along with its unique code in mongodb but also leverage redis in order to store the total number of urls that have been shortened. The idea is when you go to https://s.wllapps.com you are going to see the total number of urls right on the front page but I don\u0026rsquo;t want to do a db.collection.countDocument({}) on every request, which would have some performance issues as the application grows, therefore I keep this information in an in-memory redis instance.\nWhen the app connects to mongoDb I go ahead pull the total number of documents and store this information in a redis key. Check out the snippet below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //mongodb js module: exports.mongoConnect = callback =\u0026gt; { MongoClient.connect(process.env.MONGODB) .then(client =\u0026gt; { _db = client.db(); _db.collection(\u0026#39;codes\u0026#39;).countDocuments({},(err,number) =\u0026gt; { //pulling total number of docs  redis.getClient().set(\u0026#34;total_codes\u0026#34;, number,() =\u0026gt; { //setting redis key  callback(); }) }); }) .catch(err=\u0026gt; { log.error(err); throw err; }) };    When a user access the main route I first get the redis key value (line 4) and pass this information down to a ejs page (line 5). Note that redis is another js module\n1 2 3 4 5 6 7 8 9 10  //my router js module: //....omitted router.get(\u0026#39;/\u0026#39;, (req,res,next)=\u0026gt; { redis.getTotalCodes((total)=\u0026gt; { res.render(\u0026#39;index\u0026#39;,{count:total}) }) }) module.exports = router; //....omitted    What about new data ? The first time the apps comes up I load the total number of docs on a redis cache and every time there\u0026rsquo;s a new code I just update the cache by 1 besides adding a new document to the collection\n1 2 3 4  //...adding new mongodb doc is omitted redis.getClient().incr(\u0026#34;total_codes\u0026#34;, () =\u0026gt; { res.redirect(\u0026#39;/created\u0026#39;); })    Generating a new code I had to generate a unique code for every url which had to be short (otherwise it wouldn\u0026rsquo;t be called url shortener 😃). The first thing that came to my mind was just to use a sequential number e.g. /1 /2 /3 and so on but although it was gonna be really short \u0026ndash;up to 4 digits\u0026ndash; I didn\u0026rsquo;t want the discoverability to be that easy that people would just type a number and they could see the original page.\nI ended up leveraging mongo db document id which consists in 3 parts:\n a 4 byte timestamp value a 5 byte random value a 3 byte incremental value, initialized to a random value  I want to use the last 3 bytes which gives me what I want. First I add a new document, retrieve its id, pull the last 3 bytes out of it, create a new short code based on that and update the document.\nFirst, a module that parses mongo db id:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  exports.parse = (id) =\u0026gt; { var ctr = 0; id = id.toString(); const _timestamp = parseInt(id.slice(ctr, (ctr+=8)), 16); const _machineId = parseInt(id.slice(ctr, (ctr+=6)), 16); const _processId = parseInt(id.slice(ctr, (ctr+=4)), 16); const _counter = parseInt(id.slice(ctr, (ctr+=6)), 16); return { timestamp: new Date(_timestamp*1000), counter: _counter, machineId: _machineId, processId: _processId } }    and my controller that adds a new document, gets its add, parses the id, creates the code and updates the document again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const resultInsert = await db.collection(\u0026#39;codes\u0026#39;) .insertOne({ url:url }); var id = resultInsert.insertedId.toString(); const p = parser.parse(id); const shortenerCode = generateCode(p.counter); const resultUpdate = await db.collection(\u0026#39;codes\u0026#39;) .updateOne( {_id: new mongodb.ObjectID(id)}, {$set: { code:shortenerCode }} )   \nAdding some characters to the code The sequential number from the mongo db doc id is, wait for it\u0026hellip;, a number 😒 but I wanted to throw some characters in it in order to reduce the easiness of discovering a new code. I was able to accomplish that by converting the number to a base 32 encoding which uses a 32-character set comprising the twenty-six upper-case letters A–Z, and the digits 2–7. [more about base 32 encoding] and also reverting the string so sequential strings are not so easy to find.\n1 2 3 4  const generateCode = (sequence) =\u0026gt; { const s = sequence.toString(32); return s.split( \u0026#39;\u0026#39; ).reverse( ).join( \u0026#39;\u0026#39; ); }    and voila\u0026hellip;a working url shortener. 👍\n","href":"/posts/2020/001-url-shortener/","title":"App: A Url Shortener Web App"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/tags/mongodb/","title":"mongodb"},{"content":"","href":"/tags/myapps/","title":"myapps"},{"content":"","href":"/tags/nodejs/","title":"nodejs"},{"content":"","href":"/categories/nodejs/","title":"nodejs"},{"content":"If you use nodemon during dev you may know you can define a file called nodemon.json with all the environment variables your app uses:\n1 2 3 4 5 6 7  { \u0026#34;env\u0026#34; : { \u0026#34;APP_MONGO_CONN\u0026#34;:\u0026#34;mongodb://user:password@192.0.0.1:27017/db\u0026#34;, \u0026#34;APP_PORT\u0026#34;:3000, \u0026#34;APP_REDIS\u0026#34;:\u0026#34;redis://password@192.0.0.1\u0026#34; } }    That works just fine during development but once you publish your app to production you are on your own. We have to have those environment variables defined at the OS level otherwise your app will crash and depending on your logging strategy you may spend lots of time trying to figure it out.\nIn order to avoid such problem I like to make sure those variables exist preferably when the app comes up. The idea is if there\u0026rsquo;s any missing variable the app won\u0026rsquo;t start.\nOne solution is to check whether those variables exist individually:\n1 2 3  if (!process.env.APP_MONGO_CONN) { //do smth }    The problem with this approach is you may add a new key to nodemon.json and forget to check whether the value exist.\nA solution that I came up with is a module that checks all the names dynamically and calls an error callback in case there\u0026rsquo;s any missing item.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //function takes 2 parameters: an error and a success callback const check = (errCallback,successCallback)=\u0026gt; { const nodemon = require(\u0026#39;../nodemon.json\u0026#39;); //reading nodemon.json.  let invalidKeys = []; Object.entries(nodemon.env).forEach(([key,value]) =\u0026gt; { //pulling all the keys under env key  if (!process.env[key]) { //if it doesn\u0026#39;t exist in the host environment, it adds to the array  invalidKeys.push(key); } }) if (invalidKeys.length\u0026gt;0) errCallback(invalidKeys); else successCallback(); } module.exports = { check }    Usage in your main js file\n1 2 3 4 5 6 7 8 9 10 11 12 13  //...omitted const envChecker = require(\u0026#39;./support/envChecker\u0026#39;); envChecker.check((keys) =\u0026gt; { //error callback  log.error(\u0026#39;environment variable(s) not found: \u0026#39; + keys) }, () =\u0026gt; { //success callback  const port = process.env.APP_PORT || 3000; app.listen(port,() =\u0026gt; { log.info(`server running on port ${port}`); }); });    The app won\u0026rsquo;t start if any of the environment variables defined in the nodemon.json file don\u0026rsquo;t exist in the host, saving you hours of headaches 😏\n","href":"/posts/20200524-validating-environment-variables-in-nodejs/","title":"Automatically checking whether environment variables exist in the host OS (Nodejs)"},{"content":"","href":"/tags/csharp/","title":"csharp"},{"content":"","href":"/tags/dotnetcore/","title":"dotnetcore"},{"content":" Are you wondering where to store a jwt token in your js app ? In this video tutorial I explain where and how to store a jwt token in order to avoid XSS attacks.\n   Download source code https://github.com/wleme/JwtInJsApps\nCode Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  //file: startup.cs  public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { //Setup your asp.net core application to use token authentication  services.AddAuthentication() .AddJwtBearer(options =\u0026gt; { options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters() { ValidIssuer = Configuration[\u0026#34;Auth:Issuer\u0026#34;], ValidAudience = Configuration[\u0026#34;Auth:Audience\u0026#34;], IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[\u0026#34;Auth:Key\u0026#34;])) }; });  services.AddControllers(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseCookiePolicy(); //Create custom middleware that retrieves the jwt token from the cookie. \t//It has to come before UseAuthentication and UseAuthorization.  app.Use(async (context, next) =\u0026gt; { var jwt = context.Request.Cookies[Support.Constants.Auth.JwtCookieName]; if (jwt != null) context.Request.Headers.Add(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + jwt); await next(); });  app.UseAuthentication(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); }); } }    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  //file AuthController.cs [ApiController] [Route(\u0026#34;[CONTROLLER]\u0026#34;)]  public class AuthController : ControllerBase { private readonly IConfiguration config; public AuthController(IConfiguration config) { this.config = config; } [HttpPost] [Route(\u0026#34;login\u0026#34;)] public IActionResult Login(AuthLoginDto dto) { if (dto.UserName == \u0026#34;username\u0026#34; \u0026amp;\u0026amp; dto.Password == \u0026#34;password\u0026#34;) { var claims = new List\u0026lt;Claim\u0026gt;() { new Claim(JwtRegisteredClaimNames.Jti,Guid.NewGuid().ToString()), new Claim(JwtRegisteredClaimNames.UniqueName,dto.UserName), }; var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config[\u0026#34;Auth:Key\u0026#34;])); var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256); var token= new JwtSecurityToken( config[\u0026#34;Auth:Issuer\u0026#34;], config[\u0026#34;Auth:Audience\u0026#34;], claims, expires: DateTime.UtcNow.AddHours(1), signingCredentials: creds ); var results = new { token = new JwtSecurityTokenHandler().WriteToken(token), expirationUtc = token.ValidTo }; //Create a cookie based on a custom request header sent by the client  if (Request.Headers.TryGetValue(\u0026#34;X-Return-Cookie\u0026#34;, out var returnCookie)) { if (returnCookie.ToString().ToUpper() == true.ToString().ToUpper()) { Response.Cookies.Append(Support.Constants.Auth.JwtCookieName, results.token, new Microsoft.AspNetCore.Http.CookieOptions() { HttpOnly = true, Expires = dto.RememberMe ? results.expirationUtc : (DateTime?)null, Secure = true }); } }  return Created(\u0026#34;\u0026#34;, results); } return BadRequest(\u0026#34;Cannot login\u0026#34;); } }    ","href":"/posts/20200408-securing-jwt-js-app-1/","title":"Securing your jwt in a js app (video tutorial - part 1)"},{"content":"","href":"/tags/azure/","title":"azure"},{"content":"After almost 3 years of flawless service availability my app service came to a halt with the following event entry\n1 2 3 4 5  \u0026lt;EventData\u0026gt; \u0026lt;Data\u0026gt; .NET Runtime version 4.0.30319.0 - Loading profiler failed. Failed trying to receive from out of process a request to attach a profiler. HRESULT: 0x8007006d. Process ID (decimal): 60152. Message ID: [0x250d]. \u0026lt;/Data\u0026gt; \u0026lt;/EventData\u0026gt;   No code changes and no service changes were made so the solution was to restart the app service 😡\n","href":"/posts/0007-fix-azure-error-hresult-0x8007006d/","title":"Fix Azure Error 0x8007006d / Event Id 1022 "},{"content":"Want to start developing custom YNAB tools using .net core ? You can use this github project as a base\n[https://github.com/wleme/YnabDotNetCoreStarterKit]\nThis project successfully implements the OAuth middleware and saves the tokens in a cookie. It then retrieves the access token every time it pulls data from their API (budgets and categories within a budget). It also leverages the new HttpClientFactory (introduced on .net core 2.1).\nYou need to get your own Client Id and Client Secret and update appsettings.json.\nIssues ? Please go to github. PRs are also welcome.\nYNAB Api doc: [https://api.youneedabudget.com/]\n","href":"/posts/0006-ynab-starter-kit-net-core-2.2/","title":"YNAB starter kit in .Net Core 2.2"},{"content":"You can easily access the OAuth access token by calling\nGetTokenAsync.\nMake sure to set SaveTokens = true when setting up OAuth middleware 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public void ConfigureServices(IServiceCollection services) { services.AddAuthentication(options =\u0026gt; { options.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme; options.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme; options.DefaultChallengeScheme = \u0026#34;CustomName\u0026#34;; }) .AddCookie(options =\u0026gt; { options.Cookie.Name = \u0026#34;CustomName\u0026#34;; }) .AddOAuth(\u0026#34;CustomName\u0026#34;, options =\u0026gt; { //set all options...  options.SaveTokens = true; \t}); }    Access token You can then access the token by calling GetTokenAsync in your controller\nvar token = await HttpContext.GetTokenAsync(\u0026#34;access_token\u0026#34;); ","href":"/posts/0005-accessing-oauth-access-token-asp-core-2/","title":"Accessing OAuth access token in Asp.Net Core 2"},{"content":"","href":"/tags/api/","title":"api"},{"content":"I religiously avoid using model objects on my API interfaces. The reason is really simple, a model is a business entity and you don\u0026rsquo;t want to expose a business entity inadvertently to your API consumers.\nWhat\u0026rsquo;s the problem ? Consider the following model being used by the business layer of your application and also being returned in a get method of your API\n1 2 3 4 5 6 7  public class Product { public int Id { get; set; } public string Sku { get; set; } public string Name { get; set; } public decimal ListPrice { get; set; } }    There\u0026rsquo;s nothing special here but now the business wants to track the product markup and you decided to go with a new property:\n1 2 3 4 5 6 7 8  public class Product { public int Id { get; set; } public string Sku { get; set; } public string Name { get; set; } public decimal ListPrice { get; set; } public decimal MarkUp { get; set; } }    Now your API is also sending the product markup. Does you business want to let everybody know they are marking-up a product by 3000% ? Maybe or maybe not. Maybe your APIs are consumed only by internal apps and they are aware and have the responsability of dealing with this information but on the other hand you might be exposing the same API to external access.\nHow to determine when to use a DTO or a model in you API As I said previously you might be exposing your API only to internal apps which by sending the same Product model would be harmless. But you might be exposing the same API to external access. So the answer is a straight \u0026ldquo;it depends\u0026rdquo;. Since I don\u0026rsquo;t want to have a different approach for every single case and I like uniformity throughout my app I always go with DTOs even though they might be exactly the same as the model. The DTO allows your team-members and business to make a concious decision whether they want to share a piece of information to whoever is pulling this data from the API.\nBut be careful when using AutoMapper ⚠️ I use AutoMapper to map my models into DTOs and vice-versa. Let\u0026rsquo;s consider the following Product DTO\n1 2 3 4 5 6 7  public class ProductDto { public int Id { get; set; } public string Sku { get; set; } public string Name { get; set; } public decimal ListPrice { get; set; } }    and the following Product which has already been added\n1 2 3 4 5 6  { \u0026#34;id\u0026#34;: 1, \u0026#34;sku\u0026#34;: \u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;: 10.99 }    I want to change the name from \u0026ldquo;useless stuff\u0026rdquo; to \u0026ldquo;super useless stuff\u0026rdquo;. My Put API is implemented as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  [Route(\u0026#34;{ProductId:int}\u0026#34;)] [HttpPut] public async Task\u0026lt;IActionResult\u0026gt; Put(int productId, [FromBody] ProductDto dto) { try { if (!ModelState.IsValid) return BadRequest(ModelState); var oldProduct = await _productRepo.GetAsync(productId); if (oldProduct == null) return NotFound(); _mapper.Map(dto, oldProduct); \tawait _productRepo.UpdateAsync(oldProduct); await _productRepo.SaveAllAsync(); return Ok(_mapper.Map\u0026lt;Product, ProductDto\u0026gt;(oldProduct)); \t} catch (Exception e) { _log.LogError($\u0026#34;error updating product {e}\u0026#34;); } return BadRequest(\u0026#34;Error updating product\u0026#34;); }    We are receiving a ProductDto (line 3), pulling the product from the database, mapping the dto with it (line 10) and returning a converted ProductDto to the caller (line 14)\nRequest:\n1 2 3 4 5 6  //PUT http://localhost:59122/api/products/1 { \u0026#34;sku\u0026#34;:\u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;:\u0026#34;10.99\u0026#34; }    Response:\n1 2 3 4 5 6  { \u0026#34;id\u0026#34;: 0,  \u0026#34;sku\u0026#34;: \u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;: 10.99 }    I wanted to update product id 1 but why am I seeing id 0 ?\nYou didn\u0026rsquo;t pass any value for the Id property so the default value was set to 0. AutoMapper identified this property in the Dto and added it to the Model pulled from the Database. In the end the new merged model was updated to 0.\nHow to guarantee I\u0026rsquo;m not updating what I don\u0026rsquo;t want to update ? You could check whether the DTO Id is \u0026gt; 0 and receive the following request: 1 2 3 4 5 6 7  //PUT http://localhost:59122/api/products/1 { \u0026#34;id\u0026#34;: 1, \t\u0026#34;sku\u0026#34;:\u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;:\u0026#34;10.99\u0026#34; }   \nThe request contains the same id in both the url (line 1) and the body (line 3)\nYou would also need to make sure the id from the DTO (line 3) is the same as the id passed in the url otherwise the following request would update the wrong product:\n1 2 3 4 5 6 7  //PUT http://localhost:59122/api/products/1 { \u0026#34;id\u0026#34;: 5, \t\u0026#34;sku\u0026#34;:\u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;:\u0026#34;10.99\u0026#34; }    That\u0026rsquo;s a lot of manual checks for your controller to do. What if we guarantee they cannot update the id by simply not receiving it in the DTO ? Let\u0026rsquo;s remove the id property from the DTO:\n1 2 3 4 5 6  public class ProductDto { public string Sku { get; set; } public string Name { get; set; } public decimal ListPrice { get; set; } }    and make a new request:\n1 2 3 4 5 6  //PUT http://localhost:59122/api/products/1 { \u0026#34;sku\u0026#34;:\u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;:\u0026#34;10.99\u0026#34; }    response:\n1 2 3 4 5  { \u0026#34;sku\u0026#34;: \u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;: 10.99 }    Did it work ?\nI don\u0026rsquo;t know. I want to be able to see the Id in the response.\n1 DTO for the request and another one for the response. We want to have a DTO that doesn\u0026rsquo;t receive the Id property for the request but we do want to send everything + the Id value as a response. Hello ProductDto and ProductResponseDto:\n1 2 3 4 5 6 7 8 9 10 11  public class ProductDto { public string Sku { get; set; } public string Name { get; set; } public decimal ListPrice { get; set; } } public class ProductResponseDto:ProductDto { public int Id { get; set; } }    New Put method\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  [Route(\u0026#34;{ProductId:int}\u0026#34;)] [HttpPut] public async Task\u0026lt;IActionResult\u0026gt; Put(int productId, [FromBody] ProductDto dto)  { try { if (!ModelState.IsValid) return BadRequest(ModelState); var oldProduct = await _productRepo.GetAsync(productId); if (oldProduct == null) return NotFound(); _mapper.Map(dto, oldProduct); await _productRepo.UpdateAsync(oldProduct); await _productRepo.SaveAllAsync(); return Ok(_mapper.Map\u0026lt;Product, ProductResponseDto\u0026gt;(oldProduct));  } catch (Exception e) { _log.LogError($\u0026#34;error updating product {e}\u0026#34;); } return BadRequest(\u0026#34;Error updating product\u0026#34;); }    We are receiving a ProductDto (line 3) and returning a ProductResponseDto (line 14)\nrequest:\n1 2 3 4 5 6  //PUT http://localhost:59122/api/products/1 { \u0026#34;sku\u0026#34;:\u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;:\u0026#34;10.99\u0026#34; }    response:\n1 2 3 4 5 6  { \u0026#34;id\u0026#34;: 1, \u0026#34;sku\u0026#34;: \u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;: 10.99 }    Yes, It is working 👍 and since we are not receiving an Id in the dto we can make a request like the following:\n1 2 3 4 5 6 7  //PUT http://localhost:59122/api/products/1 { \u0026#34;id\u0026#34;: 5, \t\u0026#34;sku\u0026#34;:\u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;:\u0026#34;20.99\u0026#34; }    and the id will be safelly ignored.\nresponse: 1 2 3 4 5 6  { \u0026#34;id\u0026#34;: 1, \u0026#34;sku\u0026#34;: \u0026#34;abc01\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;super useless stuff\u0026#34;, \u0026#34;listPrice\u0026#34;: 20.99 }   \nHappy coding!\n","href":"/posts/models-and-dtos-in-your-api/","title":"Models and DTOs in Your API"},{"content":"","href":"/categories/.net/","title":".Net"},{"content":"","href":"/tags/jsonpatch/","title":"jsonpatch"},{"content":" There are 2 http verbs that can be used when updating a resource: Put and Patch but when to use one over the another ? In simplistic terms the former updates the entire resource whereas the latter updates one partially.\nLet\u0026rsquo;s code! Given the following model:\n1 2 3 4 5 6 7 8  public class Customer { public int Id { get; set; } public string FirstName { get; set; } public string MiddleName { get; set; } public string LastName { get; set; } public DateTime DateOfBirth { get; set; } }    and the following dto\u0026rsquo;s\n1 2 3 4 5 6 7 8 9 10 11 12  public class CustomerDto { public string FirstName { get; set; } public string MiddleName { get; set; } public string LastName { get; set; } public DateTime DateOfBirth { get; set; } } public class CustomerResponseDto : CustomerDto { public int Id { get; set; } }     \u0026ldquo;What the heck! You have the same thing in different places!\u0026rdquo; I never expose my models on my public Api\u0026rsquo;s even though they may be 100% identical. I like to be as explicit as possible when it comes to what information I expose over the boundaries of my app. Changing the model by adding a new property will expose the same property to the Api and that may not be what you want. There are tools such as AutoMapper that make this process of converting Model\u0026lt;-\u0026gt;Dto a breeze.\n Post implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Add([FromBody] CustomerDto customerDto) { try { if (!ModelState.IsValid) return BadRequest(ModelState); var model = _mapper.Map\u0026lt;CustomerDto, Customer\u0026gt;(customerDto); await _customerRepo.AddAsync(model); await _customerRepo.SaveAllAsync(); var output = _mapper.Map\u0026lt;Customer, CustomerResponseDto\u0026gt;(model); return Created($\u0026#34;/api/customers/{model.Id}\u0026#34;, output); } catch (Exception e) { _log.LogError($\u0026#34;error adding customer {e}\u0026#34;); } return BadRequest(); }    Post request\n1 2 3 4 5  { \u0026#34;firstName\u0026#34;:\u0026#34;Mike\u0026#34;, \u0026#34;lastName\u0026#34;:\u0026#34;Smith\u0026#34;, \u0026#34;dateOfBirth\u0026#34;:\u0026#34;06/13/1959\u0026#34; }    Post response\n1 2 3 4 5 6 7  { \u0026#34;id\u0026#34;: 1, \u0026#34;firstName\u0026#34;: \u0026#34;Mike\u0026#34;, \u0026#34;middleName\u0026#34;: null, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;dateOfBirth\u0026#34;: \u0026#34;1959-06-13T00:00:00\u0026#34; }    The new customer has been added but now I want to change it and give it a middle name. I\u0026rsquo;ll first implement the Put verb\nPut implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  [Route(\u0026#34;{customerId:int}\u0026#34;)] [HttpPut] public async Task\u0026lt;IActionResult\u0026gt; Put(int customerId, [FromBody] CustomerDto dto) { try { if (!ModelState.IsValid) return BadRequest(ModelState); var oldCustomer = await _customerRepo.GetAsync(customerId); if (oldCustomer == null) return NotFound(); _mapper.Map(dto, oldCustomer); await _customerRepo.SaveAllAsync(); return Ok(_mapper.Map\u0026lt;Customer, CustomerResponseDto\u0026gt;(oldCustomer)); } catch (Exception) { } return BadRequest(\u0026#34;Error updating customer\u0026#34;); }    As I mentioned in the beginning of this post the put verb updates the entire resource. Ie. You have to send the new property value along with everything else.\nPut request\n1 2 3 4 5 6 7  //http://localhost:59122/api/customers/1 { \u0026#34;firstName\u0026#34;:\u0026#34;Mike\u0026#34;, \u0026#34;lastName\u0026#34;:\u0026#34;Smith\u0026#34;, \u0026#34;middleName\u0026#34;:\u0026#34;J.\u0026#34;, \u0026#34;dateOfBirth\u0026#34;:\u0026#34;06/13/1959\u0026#34; }    Put response\n1 2 3 4 5 6 7  { \u0026#34;id\u0026#34;: 1, \u0026#34;firstName\u0026#34;: \u0026#34;Mike\u0026#34;, \u0026#34;middleName\u0026#34;: \u0026#34;J.\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;dateOfBirth\u0026#34;: \u0026#34;1959-06-13T00:00:00\u0026#34; }    The client needs to first issue a get, update the property and then issue a put. What if we try to make the client faster by eliminating the first call and just send up the property that has changed ?\nPut implementation - trying to send only 1 property Put request:\n1 2 3 4  //http://localhost:59122/api/customers/1 { \u0026#34;middleName\u0026#34;:\u0026#34;J.\u0026#34; }    Put response:\n1 2 3 4 5 6 7  { \u0026#34;id\u0026#34;: 1, \u0026#34;firstName\u0026#34;: null, \u0026#34;middleName\u0026#34;: \u0026#34;J.\u0026#34;, \u0026#34;lastName\u0026#34;: null, \u0026#34;dateOfBirth\u0026#34;: \u0026#34;0001-01-01T00:00:00\u0026#34; }    \u0026ldquo;Oh No!!!Where\u0026rsquo;s everything else ?!\u0026rdquo; Sorry, but you have updated the entire resource and lost all those values. Hopefully your back-up is up-to-date. 😃\n\u0026ldquo;Bummer! Ok, I\u0026rsquo;ll check for null properties and update the resource accordingly\u0026rdquo; Not quite there! What if you want to update a field to Null ?\nWhat we want to do is to update the resource partially. Ie. We want to patch it but by just having a new verb Patch is not magically handle everything for you. You need to send to the api endpoint not just the new value but what you are doing with it.\nHello JSON Patch 💗 JSON Patch is a contract for describing changes on a JSON document in a very explicit way. You client can tell things such as whether they are adding, replacing or removing values from the JSON document.\nPatch implementation You first need to pull in a package called \u0026ldquo;JSON Patch\u0026rdquo; which adds support to your .Net Core Api\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  [Route(\u0026#34;{customerId:int}\u0026#34;)] [HttpPatch] public async Task\u0026lt;IActionResult\u0026gt; Patch(int customerId, [FromBody] JsonPatchDocument\u0026lt;CustomerDto\u0026gt; patchModel) { try { var customerDb = await _customerRepo.GetAsync(customerId); if (customerDb == null) return NotFound(); var customerDbDto = _mapper.Map\u0026lt;Customer, CustomerDto\u0026gt;(customerDb); patchModel.ApplyTo(customerDbDto); _mapper.Map(customerDbDto, customerDb); await _customerRepo.UpdateAsync(customerDb); await _customerRepo.SaveAllAsync(); return Ok(_mapper.Map\u0026lt;Customer, CustomerResponseDto\u0026gt;(customerDb)); } catch (Exception e) { _log.LogError($\u0026#34;error updating customer {e}\u0026#34;); } return BadRequest(\u0026#34;Error updating customer\u0026#34;); }    Since we are receiving a \u0026lt; CustomerDto \u0026gt; we first need to convert the database entry to the same dto type (line 9) and then we patch it with the values that are coming in (line 11). Now we can merge the original model with the dto which will result in a model with the updated values (line 12).\nWhat my clients need to send ? Your clients need to explicitly say what they are doing. Ie. They need to send up a specific JSON document:\n1 2 3 4 5  [ { \u0026#34;op\u0026#34;: \u0026#34;replace\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/baz\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;boo\u0026#34; }, { \u0026#34;op\u0026#34;: \u0026#34;add\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/hello\u0026#34;, \u0026#34;value\u0026#34;: [\u0026#34;world\u0026#34;] }, { \u0026#34;op\u0026#34;: \u0026#34;remove\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/foo\u0026#34; } ]    The sample above has 3 operations Replace, Add and Remove. The first one replaces the value of a property named baz. The 2nd one adds a new property to the document and the 3rd one removes.\nNow we have everything in place and we can finally send just a single property:\nPatch request:\n1 2 3 4  //http://localhost:59122/api/customers/1 [ {\u0026#34;op\u0026#34; : \u0026#34;replace\u0026#34;, \u0026#34;path\u0026#34; : \u0026#34;middleName\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;J.\u0026#34;} ]    Patch response:\n1 2 3 4 5 6 7  { \u0026#34;id\u0026#34;: 1, \u0026#34;firstName\u0026#34;: \u0026#34;Mike\u0026#34;, \u0026#34;middleName\u0026#34;: \u0026#34;J.\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;dateOfBirth\u0026#34;: \u0026#34;1959-06-13T00:00:00\u0026#34; }    Source Code\n","href":"/posts/put-vs-patch-api-net-core/","title":"Put vs Patch Api in .Net Core"},{"content":"","href":"/categories/devops/","title":"DevOps"},{"content":"","href":"/tags/devops/","title":"devops"},{"content":" In this tutorial we will pull a Sql Server docker image, create a docker-compose script and connect to this new server using SSMS (sql server management studio) I keep all my databases, queues and other infrastructure tools on a linux box running as docker containers. Docker gives me the flexibility of installing multiple things without messing up my dev environment and I recently added SqlServer\nPull the docker image into your linux box sudo docker pull mcr.microsoft.com/mssql/server Install docker compose (if you don\u0026rsquo;t have it) sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose Create a new docker-compose.yml file sudo nano docker-compose.yml and type the following: (The configuration below will run the sql server container in the developer edition) version: \u0026#39;3\u0026#39; services: sqlserver: image: mcr.microsoft.com/mssql/server:latest container_name: sqlserver1 restart: always environment: - \u0026#34;ACCEPT_EULA=Y\u0026#34; - \u0026#34;MSSQL_SA_PASSWORD=\u0026lt;YourStrong!Passw0rd\u0026gt;\u0026#34; volumes: - ./data/sqlserver1/:/var/opt/mssql ports: - \u0026#34;1433:1433\u0026#34;\n Line 4 - Specifies the docker image we have just pulled. Line 6 - Tells the container it will always be restarted. Line 8-9 - Specific variables required by Sql Server. Note we are supplying the sa password here. Line 11 - It specifies where the data will be persisted. If you don\u0026rsquo;t specify anything here and remove the sql server container you will lose all the data. Line 13 - It exposes the container outside the docker. You want to map the port otherwise you won\u0026rsquo;t have access to sql server from your dev environment.  now we can start docker compose sudo docker-compose up\nand make sure sql server is up sudo docker ps -a you should see the following Connecting via SSMS Now that the server is up and running and the container is exposed to connections outside the docker, we are able to use it normally and connect to it via SSMS or our application.\n","href":"/posts/installing-sqlserver-on-linux/","title":"Installing SqlServer on Linux"},{"content":"","href":"/tags/linux/","title":"linux"},{"content":"","href":"/tags/sqlserver/","title":"sqlserver"},{"content":"","href":"/tags/enumerators/","title":"enumerators"},{"content":" You should never make your api consumers understand your enums. They should never send or receive numbers (10, 20, \u0026hellip;) for things like AddressType, Gender, Day of the week and so forth. What does number 10 mean anyway ? You don\u0026rsquo;t even know yourself! This project shows how we can deal with a string coming in, convert it to an enumerator and respond to the caller by sending a string again.\nOur api receives a new address and adds it to the database (there\u0026rsquo;s no database though). An address can be \u0026lsquo;Home\u0026rsquo; or \u0026lsquo;Office\u0026rsquo; and they are represented by the following:\npublic class Address { public int Id { get; set; } public string StreetName { get; set; } public AddressType AddressType { get; set; } }  public enum AddressType: int { Home = 10, Office =20 }  Again, you don\u0026rsquo;t want to make your api consumers understand your enums. They should send and receive Home or Office instead of 10 or 20.\nCreate a new dto with a custom validator Create a new dto that will receive the data in your post method and add a custom validator that will make sure the string supplied is valid. The custom validator tries to convert the string supplied to a valid AddressType enum. It also re-sets the string to the string representation of the enum. Ie. If you send up \u0026ldquo;hOme\u0026rdquo;, the string will be converted back to \u0026ldquo;Home\u0026rdquo;.\npublic class AddressDto : IValidatableObject { [Required] public string StreetName { get; set; } public string AddressType { get; set; } public IEnumerable\u0026lt;ValidationResult\u0026gt; Validate(ValidationContext validationContext) { if (!Enum.TryParse(Type,true,out AddressType result)) { yield return new ValidationResult(\u0026#34;Invalid address type\u0026#34;, new[] { nameof(AddressType) }); } Type = result.ToString(); //normalize Type  } }  Receive the dto in your api method The controller needs to validate the model which, according to our custom validator above, will not be valid if they send up something different than home or office. It also converts the dto to the model using automapper, adds the model and converts the model to a response dto.\n[HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Add([FromBody] AddressDto addressDto) { try { if (!ModelState.IsValid) return BadRequest(ModelState); var model = _mapper.Map\u0026lt;AddressDto, Address\u0026gt;(addressDto); await _addressRepo.AddAsync(model); await _addressRepo.SaveAllAsync(); var output = _mapper.Map\u0026lt;Address, AddressResponseDto\u0026gt;(model); return Created($\u0026#34;/api/addresses/{model.Id}\u0026#34;, output); } catch (Exception e) { _log.LogError($\u0026#34;error adding address {e}\u0026#34;); } return BadRequest(); }  Converting dto to Model We use automapper to convert objects from/to different types. When we convert from AddressDto to Address we need to tell automapper that the string of AddressDto.AddressType needs to be set to a enum in the Address.AddressType and we do that by creating the following profile: public class AutoMapperProfile : Profile { public AutoMapperProfile() { CreateMap\u0026lt;AddressDto, Address\u0026gt;() .ForMember(o =\u0026gt; o.AddressType, ex =\u0026gt; ex.MapFrom(o =\u0026gt; Enum.Parse(typeof(AddressType), o.AddressType))); //maps from string to enum  CreateMap\u0026lt;Address, AddressResponseDto\u0026gt;(); } }  The profile above also creates a map between Address and AddressResponseDto.\nResponseDto The difference between the request dto and the response dto is the response has an Id field and the AddressType is the enum itself and no longer a string. The idea here is you always deal with an enumerator within your application and only have the string representation if you are receiving/sending data from/to your api consumer. public class AddressResponseDto { public int Id { get; set; } public string StreetName { get; set; } public AddressType AddressType{ get; set; } } \nBut we are sending back to the consumer the AddressResponseDto which uses an enumerator. How do we convert it to string?\nWe could convert manually on every method that deals with the same dto but that would mean duplication all over. What we do instead is we set a default JSON serializer which converts ALL enums to a string in startup.cs:\npublic void ConfigureServices(IServiceCollection services) { services.AddAutoMapper(); services.AddSingleton\u0026lt;IAddressRepo, AddressRepoInMemory\u0026gt;(); services.AddMvc() .AddJsonOptions(opt =\u0026gt; { opt.SerializerSettings.Converters.Add(new Newtonsoft.Json.Converters.StringEnumConverter()); //serialize all enums  }); }  Source Code\n","href":"/posts/how-to-handle-enums-net-core/","title":"Enumerators in your Api - How to handle enums in your .Net Core Api"},{"content":"","href":"/tags/enums/","title":"enums"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"},{"content":"Hello,\nI publish my toy projects at https://wllapps.com. You can find a list of them here and more about me here.\n","href":"/wllapps/","title":"wllapps"}]
